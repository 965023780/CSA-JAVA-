# 一、泛型的概念

泛型：**把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型**

- `ArrayList<E>`中的**E称为类型参数变量**
- `ArrayList<Integer>`中的**Integer称为实际类型参数**
- **整个称为`ArrayList<E>`泛型类型**
- **整个`ArrayList<Integer>`称为参数化的类型**
- **T意味某种类型  **
- **E意味 链表、数组里的元素，如`ArrayList<E>`。**
- **K意味map(k,v) 里的键值 Key**
- **V意味返回或映射的值,即value。**

# 二、为什么需要泛型

**早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题，这样程序就不太安全**

那么就会导致：

- Object意味着集合对元素的类型是没有任何限制的。**例如`ArrayList<Object>`既可以放入Integer也可以放入String**
- 正如上一项所说，仅仅知道是Object。因此在get()的时候，返回的是Object。**外边获取该对象，还需要进行强制转换。**

有了泛型以后：

- 代码更加简洁
- 程序更加健壮
- 可读性和稳定性

# 三、泛型应用

## 3.1泛型类

**泛型类就是把泛型定义在类上，用户使用该类的时候，才把类型明确下来**

- **在类上定义的泛型，在类的方法中也可以使用**
- **泛型只对非静态成员有效**

## 3.2泛型方法

**有的时候我们不需要对整个类进行泛型定义，仅仅是某一个方法上需要使用泛型，那么这个时候就需要泛型方法了**

## 3.3泛型类的子类

泛型类的子类有两种分类情况：

1. **子类明确泛型类的类型参数变量**
2. **子类不明确泛型类的类型参数变量**

### 3.3.1子类明确泛型类的类型参数变量

- **泛型接口**

- **实现泛型接口**

### 3.3.2子类不明确泛型类的类型参数变量

- **外界使用时，也需要确定子类的泛型类的类型参数**

- **实现类的要是重写父类的方法，返回值的类型是要一样**

------

## 3.4类型通配符

**?号通配符表示可以匹配任意类型，任意的Java类都可以匹配**

当我们使用?号通配符的时候：**就只能调对象与类型无关的方法，不能调用对象与类型有关的方法。因为直到使用的时候，我们才知道具体的类型是什么。也就是说，在示例代码中的List集合，是不能使用add()方法的。因为add()方法是把对象丢进集合中，而现在我是不知道对象的类型是什么。**

------

### 3.4.1设定通配符上限

现在，我想接收一个List集合，它只能操作数字类型的元素。

因此我们需要**用到设定通配符上限**

```
List<? extends Number>
```

上面的代码表示的是：**List集合装载的元素只能是Number的子类或自身**

### 3.4.2设定通配符下限

现在，我想接收一个List集合，**它只能操作Base类的父类或自身**。

因此我们需要**用到设定通配符上限**

```
List<? super Base>
```

## 3.5通配符和泛型方法

**大多时候，我们都可以使用泛型方法来代替通配符的**

- 如果**参数之间的类型有依赖关系**，或者返**回值是与参数之间有依赖关系**的。那么就使用**泛型方法**
- 如果**没有依赖关系**的，就使用**通配符**，通配符会**灵活一些.**

------

## 3.6类型擦除

泛型是**提供给javac编译器使用的**，它用于限定集合的输入类型，让编译器在源代码级别上，即挡住向集合中插入非法数据。但编译器编译完带有泛形的java程序后，**生成的class文件中将不再带有泛形信息**，以此使程序运行效率不受到影响，这个过程称之为“擦除”。

# 四、反射的概念

反射：**JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制**

# 五、为什么需要反射

**反射是Java被视为动态（或准动态）语言的一个关键性质，赋予了JVM动态编译的能力，否则类的元数据信息只能用静态编译（编译时确定的类型）的方式实现**

- **TomCat的classloader**
- **JSON解析工具**
- **热加载**

# 六、反射的基础应用

## 6.1 获取类

- getClass方法
- Class.forName方法

## 6.2获取类的成员属性

- **可以通过反射获取类的私有属性和方法**
- **获取类的所有属性**
- **获取类的私有属性**
- **调用类的属性**

## 6.3**获取类的构造函数**

- **可以通过反射获取类的私有属性和方法**
- getModifiers()方法说明：**一个成员属性/方法修饰符什么都不加，返回结果是0 ，public 是1 ，private 是 2 ，protected 是 4，static 是 8 ，final 是 16。**
- 可以通过Modifier.toString()方法得到修饰符
- **获取类的所有构造函数**
- **获取类的特定构造函数**
- **调用构造函数**

## 6.4获取类的成员方法

- **可以通过反射获取类的私有属性和方法**
- **获取类的所有方法**
- **获取类的私有方法**
- **调用类的方法**

# 七、线程的概念

线程：**线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。**

# 八、线程的状态

- **创建（new）：一个尚未启动的线程的状态。**
- **就绪（runnable）：一个可以运行的线程的状态，可以运行是指这个线程已经在JVM中运行了，但是有可能正在等待其他的系统资源。**
- **阻塞（blocked）：一个线程因为等待监视锁而被阻塞的状态。**
- **等待（waiting）：一个正在等待的线程的状态。造成线程等待的原因有三种，分别是调用Object.wait()、join()以及LockSupport.park()方法。**
- **限时等待（time waiting）：一个在限定时间内等待的线程的状态。**
- **结束（terminated）：一个完全运行完成的线程的状态。**

![线程状态转移图](C:\Users\lenovo\Desktop\csa\线程状态转移图.jpg)